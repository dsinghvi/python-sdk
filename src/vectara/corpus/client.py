# This file was auto-generated by Fern from our API Definition.

import json
import typing
from json.decoder import JSONDecodeError

from ..core.api_error import ApiError
from ..core.client_wrapper import AsyncClientWrapper, SyncClientWrapper
from ..core.jsonable_encoder import jsonable_encoder
from ..core.pagination import AsyncPager, SyncPager
from ..core.pydantic_utilities import pydantic_v1
from ..core.request_options import RequestOptions
from ..errors.bad_request_error import BadRequestError
from ..errors.forbidden_error import ForbiddenError
from ..errors.not_found_error import NotFoundError
from ..types.bad_request_error_body import BadRequestErrorBody
from ..types.corpus import Corpus
from ..types.corpus_custom_dimension import CorpusCustomDimension
from ..types.corpus_key import CorpusKey
from ..types.error import Error
from ..types.filter_attribute import FilterAttribute
from ..types.generation_parameters import GenerationParameters
from ..types.list_corpora_response import ListCorporaResponse
from ..types.not_found_error_body import NotFoundErrorBody
from ..types.query_full_response import QueryFullResponse
from ..types.query_streamed_response import QueryStreamedResponse
from ..types.replace_filter_attributes_response import ReplaceFilterAttributesResponse
from .types.search_corpus_parameters import SearchCorpusParameters

# this is used as the default value for optional parameters
OMIT = typing.cast(typing.Any, ...)


class CorpusClient:
    def __init__(self, *, client_wrapper: SyncClientWrapper):
        self._client_wrapper = client_wrapper

    def list(
        self,
        *,
        limit: typing.Optional[int] = None,
        filter: typing.Optional[str] = None,
        page_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> SyncPager[Corpus]:
        """
        List corpora in the account. The corpus objects that are returned are less
        detailed than the direct corpus retrieval operation.

        Parameters
        ----------
        limit : typing.Optional[int]
            The maximum number of corpora to return at one time.

        filter : typing.Optional[str]
            A regular expression to filter the corpora by their name or summary.

        page_key : typing.Optional[str]
            Used to retrieve the next page of corpora after the limit has been reached.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        SyncPager[Corpus]
            List of corpora.

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.list()
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/corpora",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"limit": limit, "filter": filter, "page_key": page_key},
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(ListCorporaResponse, _response.json())  # type: ignore
            _has_next = False
            _get_next = None
            if _parsed_response.metadata is not None:
                _parsed_next = _parsed_response.metadata.page_key
                _has_next = _parsed_next is not None
                _get_next = lambda: self.list(
                    limit=limit, filter=filter, page_key=_parsed_next, request_options=request_options
                )
            _items = _parsed_response.corpora
            return SyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def create(
        self,
        *,
        key: CorpusKey,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        queries_are_answers: typing.Optional[bool] = OMIT,
        documents_are_questions: typing.Optional[bool] = OMIT,
        encoder_id: typing.Optional[str] = OMIT,
        filter_attributes: typing.Optional[typing.Sequence[FilterAttribute]] = OMIT,
        custom_dimensions: typing.Optional[typing.Sequence[CorpusCustomDimension]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Corpus:
        """
        Create a corpus, which is a container to store documents and associated metadata.

        Parameters
        ----------
        key : CorpusKey

        name : typing.Optional[str]
            The name for the corpus. This value defaults to the key.

        description : typing.Optional[str]
            Description for the corpus.

        queries_are_answers : typing.Optional[bool]
            Queries made to this corpus are considered answers, and not questions.

        documents_are_questions : typing.Optional[bool]
            Documents inside this corpus are considered questions, and not answers.

        encoder_id : typing.Optional[str]
            The encoder used by the corpus. This value defaults to the most recent Vectara encoder.

        filter_attributes : typing.Optional[typing.Sequence[FilterAttribute]]
            The new filter attributes of the corpus.
            If unset then the corpus will not have filter attributes.


        custom_dimensions : typing.Optional[typing.Sequence[CorpusCustomDimension]]
            A custom dimension is an additional numerical field attached to a document part. You
            can then multiply this numerical field with a query time custom dimension of the same
            name. This allows boosting (or deboosting) document parts for arbitrary reasons.
            This feature is only enabled for Scale customers.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            The corpus has been created.

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.create(
            key="my-corpus",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            "v2/corpora",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={
                "key": key,
                "name": name,
                "description": description,
                "queries_are_answers": queries_are_answers,
                "documents_are_questions": documents_are_questions,
                "encoder_id": encoder_id,
                "filter_attributes": filter_attributes,
                "custom_dimensions": custom_dimensions,
            },
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def get(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> Corpus:
        """
        Get metadata about a corpus. This operation is not a method of searching a corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            A corpus.

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.get(
            corpus_key="my-corpus",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def delete(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a corpus and all the data that it contains.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.delete(
            corpus_key="my-corpus",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def update(
        self,
        corpus_key: CorpusKey,
        *,
        enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Corpus:
        """
        Enable or disable a corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to update.

        enabled : typing.Optional[bool]
            Set whether or not the corpus is enabled. If unset then the corpus will remain in the same state.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            Succcessfully modified the corpus.

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.update(
            corpus_key="my-corpus",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="PATCH",
            json={"enabled": enabled},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def reset(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Resets a corpus, which removes all documents and data from the specified corpus, while keeping the corpus itself.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to reset.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.reset(
            corpus_key="my-corpus",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/reset",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def replace_filter_attributes(
        self,
        corpus_key: CorpusKey,
        *,
        filter_attributes: typing.Sequence[FilterAttribute],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ReplaceFilterAttributesResponse:
        """
        Replace the filter attributes of a corpus. This does not happen immediately, but
        instead creates a job and will complete when that job completes. Until that
        job completes, using new filter attributes will not work.

        You can monitor the status of the filter change using the returned job id.

        Parameters
        ----------
        corpus_key : CorpusKey
            Key of the corpus to have filters replaced.

        filter_attributes : typing.Sequence[FilterAttribute]
            The new filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ReplaceFilterAttributesResponse
            Succesfully created a job that will replace the filter attributes.

        Examples
        --------
        from vectara import FilterAttribute
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.replace_filter_attributes(
            corpus_key="my-corpus",
            filter_attributes=[
                FilterAttribute(
                    name="Title",
                    level="document",
                    type="integer",
                )
            ],
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/replace_filter_attributes",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"filter_attributes": filter_attributes},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ReplaceFilterAttributesResponse, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def search(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QueryFullResponse:
        """
        Search a single corpus with a simple query request.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The search query string for the corpus.

        limit : typing.Optional[int]
            Maximum number of results to return.

        offset : typing.Optional[int]
            Position from which to start in the result set.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QueryFullResponse
            A response to a query.

        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.search(
            corpus_key="my-corpus",
            query="query",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"query": query, "limit": limit, "offset": offset},
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(QueryFullResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    def stream_query(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        search: typing.Optional[SearchCorpusParameters] = OMIT,
        generation: typing.Optional[GenerationParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.Iterator[QueryStreamedResponse]:
        """
        Query a specific corpus and find relevant results, highlight relevant snippets, and use Retrival Augmented Generation.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The query to receive an answer on.

        search : typing.Optional[SearchCorpusParameters]
            The parameters to search one corpus.

        generation : typing.Optional[GenerationParameters]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.Iterator[QueryStreamedResponse]


        Examples
        --------
        from vectara import (
            CitationParameters,
            ContextConfiguration,
            GenerationParameters,
            ModelParameters,
            SearchCorpusParameters,
            SearchReranker_CustomerReranker,
        )
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        response = client.corpus.stream_query(
            corpus_key="string",
            query="string",
            search=SearchCorpusParameters(
                custom_dimensions={"string": 1.1},
                metadata_filter="string",
                lexical_interpolation=1.1,
                semantics="default",
                offset=1,
                limit=1,
                context_configuration=ContextConfiguration(),
                reranker=SearchReranker_CustomerReranker(),
            ),
            generation=GenerationParameters(
                prompt_name="string",
                max_used_search_results=1,
                prompt_text="string",
                max_response_characters=1,
                response_language="auto",
                model_parameters=ModelParameters(
                    max_tokens=1,
                    temperature=1.1,
                    frequency_penalty=1.1,
                    presence_penalty=1.1,
                ),
                citations=CitationParameters(),
                enable_factual_consistency_score=True,
            ),
        )
        for chunk in response:
            yield chunk
        """
        with self._client_wrapper.httpx_client.stream(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"query": query, "search": search, "generation": generation, "stream_response": True},
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            if 200 <= _response.status_code < 300:
                for _text in _response.iter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic_v1.parse_obj_as(QueryStreamedResponse, json.loads(_text))  # type: ignore
                return
            _response.read()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    def query(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        search: typing.Optional[SearchCorpusParameters] = OMIT,
        generation: typing.Optional[GenerationParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QueryFullResponse:
        """
        Query a specific corpus and find relevant results, highlight relevant snippets, and use Retrival Augmented Generation.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The query to receive an answer on.

        search : typing.Optional[SearchCorpusParameters]
            The parameters to search one corpus.

        generation : typing.Optional[GenerationParameters]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QueryFullResponse


        Examples
        --------
        from vectara.client import Vectara

        client = Vectara(
            api_key="YOUR_API_KEY",
        )
        client.corpus.query(
            corpus_key="my-corpus",
            query="query",
        )
        """
        _response = self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"query": query, "search": search, "generation": generation, "stream_response": False},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(QueryFullResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)


class AsyncCorpusClient:
    def __init__(self, *, client_wrapper: AsyncClientWrapper):
        self._client_wrapper = client_wrapper

    async def list(
        self,
        *,
        limit: typing.Optional[int] = None,
        filter: typing.Optional[str] = None,
        page_key: typing.Optional[str] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> AsyncPager[Corpus]:
        """
        List corpora in the account. The corpus objects that are returned are less
        detailed than the direct corpus retrieval operation.

        Parameters
        ----------
        limit : typing.Optional[int]
            The maximum number of corpora to return at one time.

        filter : typing.Optional[str]
            A regular expression to filter the corpora by their name or summary.

        page_key : typing.Optional[str]
            Used to retrieve the next page of corpora after the limit has been reached.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        AsyncPager[Corpus]
            List of corpora.

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.list()
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/corpora",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"limit": limit, "filter": filter, "page_key": page_key},
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            _parsed_response = pydantic_v1.parse_obj_as(ListCorporaResponse, _response.json())  # type: ignore
            _has_next = False
            _get_next = None
            if _parsed_response.metadata is not None:
                _parsed_next = _parsed_response.metadata.page_key
                _has_next = _parsed_next is not None
                _get_next = lambda: self.list(
                    limit=limit, filter=filter, page_key=_parsed_next, request_options=request_options
                )
            _items = _parsed_response.corpora
            return AsyncPager(has_next=_has_next, items=_items, get_next=_get_next)
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def create(
        self,
        *,
        key: CorpusKey,
        name: typing.Optional[str] = OMIT,
        description: typing.Optional[str] = OMIT,
        queries_are_answers: typing.Optional[bool] = OMIT,
        documents_are_questions: typing.Optional[bool] = OMIT,
        encoder_id: typing.Optional[str] = OMIT,
        filter_attributes: typing.Optional[typing.Sequence[FilterAttribute]] = OMIT,
        custom_dimensions: typing.Optional[typing.Sequence[CorpusCustomDimension]] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Corpus:
        """
        Create a corpus, which is a container to store documents and associated metadata.

        Parameters
        ----------
        key : CorpusKey

        name : typing.Optional[str]
            The name for the corpus. This value defaults to the key.

        description : typing.Optional[str]
            Description for the corpus.

        queries_are_answers : typing.Optional[bool]
            Queries made to this corpus are considered answers, and not questions.

        documents_are_questions : typing.Optional[bool]
            Documents inside this corpus are considered questions, and not answers.

        encoder_id : typing.Optional[str]
            The encoder used by the corpus. This value defaults to the most recent Vectara encoder.

        filter_attributes : typing.Optional[typing.Sequence[FilterAttribute]]
            The new filter attributes of the corpus.
            If unset then the corpus will not have filter attributes.


        custom_dimensions : typing.Optional[typing.Sequence[CorpusCustomDimension]]
            A custom dimension is an additional numerical field attached to a document part. You
            can then multiply this numerical field with a query time custom dimension of the same
            name. This allows boosting (or deboosting) document parts for arbitrary reasons.
            This feature is only enabled for Scale customers.


        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            The corpus has been created.

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.create(
            key="my-corpus",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            "v2/corpora",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={
                "key": key,
                "name": name,
                "description": description,
                "queries_are_answers": queries_are_answers,
                "documents_are_questions": documents_are_questions,
                "encoder_id": encoder_id,
                "filter_attributes": filter_attributes,
                "custom_dimensions": custom_dimensions,
            },
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def get(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> Corpus:
        """
        Get metadata about a corpus. This operation is not a method of searching a corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to retrieve.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            A corpus.

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.get(
            corpus_key="my-corpus",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def delete(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Delete a corpus and all the data that it contains.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to delete

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.delete(
            corpus_key="my-corpus",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="DELETE",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def update(
        self,
        corpus_key: CorpusKey,
        *,
        enabled: typing.Optional[bool] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> Corpus:
        """
        Enable or disable a corpus.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to update.

        enabled : typing.Optional[bool]
            Set whether or not the corpus is enabled. If unset then the corpus will remain in the same state.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        Corpus
            Succcessfully modified the corpus.

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.update(
            corpus_key="my-corpus",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}",
            base_url=self._client_wrapper.get_environment().default,
            method="PATCH",
            json={"enabled": enabled},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(Corpus, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def reset(self, corpus_key: CorpusKey, *, request_options: typing.Optional[RequestOptions] = None) -> None:
        """
        Resets a corpus, which removes all documents and data from the specified corpus, while keeping the corpus itself.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to reset.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        None

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.reset(
            corpus_key="my-corpus",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/reset",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def replace_filter_attributes(
        self,
        corpus_key: CorpusKey,
        *,
        filter_attributes: typing.Sequence[FilterAttribute],
        request_options: typing.Optional[RequestOptions] = None,
    ) -> ReplaceFilterAttributesResponse:
        """
        Replace the filter attributes of a corpus. This does not happen immediately, but
        instead creates a job and will complete when that job completes. Until that
        job completes, using new filter attributes will not work.

        You can monitor the status of the filter change using the returned job id.

        Parameters
        ----------
        corpus_key : CorpusKey
            Key of the corpus to have filters replaced.

        filter_attributes : typing.Sequence[FilterAttribute]
            The new filter attributes.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        ReplaceFilterAttributesResponse
            Succesfully created a job that will replace the filter attributes.

        Examples
        --------
        from vectara import FilterAttribute
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.replace_filter_attributes(
            corpus_key="my-corpus",
            filter_attributes=[
                FilterAttribute(
                    name="Title",
                    level="document",
                    type="integer",
                )
            ],
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/replace_filter_attributes",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"filter_attributes": filter_attributes},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(ReplaceFilterAttributesResponse, _response.json())  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def search(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        limit: typing.Optional[int] = None,
        offset: typing.Optional[int] = None,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QueryFullResponse:
        """
        Search a single corpus with a simple query request.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The search query string for the corpus.

        limit : typing.Optional[int]
            Maximum number of results to return.

        offset : typing.Optional[int]
            Position from which to start in the result set.

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QueryFullResponse
            A response to a query.

        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.search(
            corpus_key="my-corpus",
            query="query",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="GET",
            params={"query": query, "limit": limit, "offset": offset},
            request_options=request_options,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(QueryFullResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

    async def stream_query(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        search: typing.Optional[SearchCorpusParameters] = OMIT,
        generation: typing.Optional[GenerationParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> typing.AsyncIterator[QueryStreamedResponse]:
        """
        Query a specific corpus and find relevant results, highlight relevant snippets, and use Retrival Augmented Generation.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The query to receive an answer on.

        search : typing.Optional[SearchCorpusParameters]
            The parameters to search one corpus.

        generation : typing.Optional[GenerationParameters]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Yields
        ------
        typing.AsyncIterator[QueryStreamedResponse]


        Examples
        --------
        from vectara import (
            CitationParameters,
            ContextConfiguration,
            GenerationParameters,
            ModelParameters,
            SearchCorpusParameters,
            SearchReranker_CustomerReranker,
        )
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        response = await client.corpus.stream_query(
            corpus_key="string",
            query="string",
            search=SearchCorpusParameters(
                custom_dimensions={"string": 1.1},
                metadata_filter="string",
                lexical_interpolation=1.1,
                semantics="default",
                offset=1,
                limit=1,
                context_configuration=ContextConfiguration(),
                reranker=SearchReranker_CustomerReranker(),
            ),
            generation=GenerationParameters(
                prompt_name="string",
                max_used_search_results=1,
                prompt_text="string",
                max_response_characters=1,
                response_language="auto",
                model_parameters=ModelParameters(
                    max_tokens=1,
                    temperature=1.1,
                    frequency_penalty=1.1,
                    presence_penalty=1.1,
                ),
                citations=CitationParameters(),
                enable_factual_consistency_score=True,
            ),
        )
        async for chunk in response:
            yield chunk
        """
        async with self._client_wrapper.httpx_client.stream(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"query": query, "search": search, "generation": generation, "stream_response": True},
            request_options=request_options,
            omit=OMIT,
        ) as _response:
            if 200 <= _response.status_code < 300:
                async for _text in _response.aiter_lines():
                    if len(_text) == 0:
                        continue
                    yield pydantic_v1.parse_obj_as(QueryStreamedResponse, json.loads(_text))  # type: ignore
                return
            await _response.aread()
            if _response.status_code == 400:
                raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
            if _response.status_code == 403:
                raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
            if _response.status_code == 404:
                raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
            try:
                _response_json = _response.json()
            except JSONDecodeError:
                raise ApiError(status_code=_response.status_code, body=_response.text)
            raise ApiError(status_code=_response.status_code, body=_response_json)

    async def query(
        self,
        corpus_key: CorpusKey,
        *,
        query: str,
        search: typing.Optional[SearchCorpusParameters] = OMIT,
        generation: typing.Optional[GenerationParameters] = OMIT,
        request_options: typing.Optional[RequestOptions] = None,
    ) -> QueryFullResponse:
        """
        Query a specific corpus and find relevant results, highlight relevant snippets, and use Retrival Augmented Generation.

        Parameters
        ----------
        corpus_key : CorpusKey
            The unique key identifying the corpus to query.

        query : str
            The query to receive an answer on.

        search : typing.Optional[SearchCorpusParameters]
            The parameters to search one corpus.

        generation : typing.Optional[GenerationParameters]

        request_options : typing.Optional[RequestOptions]
            Request-specific configuration.

        Returns
        -------
        QueryFullResponse


        Examples
        --------
        from vectara.client import AsyncVectara

        client = AsyncVectara(
            api_key="YOUR_API_KEY",
        )
        await client.corpus.query(
            corpus_key="my-corpus",
            query="query",
        )
        """
        _response = await self._client_wrapper.httpx_client.request(
            f"v2/corpora/{jsonable_encoder(corpus_key)}/query",
            base_url=self._client_wrapper.get_environment().default,
            method="POST",
            json={"query": query, "search": search, "generation": generation, "stream_response": False},
            request_options=request_options,
            omit=OMIT,
        )
        if 200 <= _response.status_code < 300:
            return pydantic_v1.parse_obj_as(QueryFullResponse, _response.json())  # type: ignore
        if _response.status_code == 400:
            raise BadRequestError(pydantic_v1.parse_obj_as(BadRequestErrorBody, _response.json()))  # type: ignore
        if _response.status_code == 403:
            raise ForbiddenError(pydantic_v1.parse_obj_as(Error, _response.json()))  # type: ignore
        if _response.status_code == 404:
            raise NotFoundError(pydantic_v1.parse_obj_as(NotFoundErrorBody, _response.json()))  # type: ignore
        try:
            _response_json = _response.json()
        except JSONDecodeError:
            raise ApiError(status_code=_response.status_code, body=_response.text)
        raise ApiError(status_code=_response.status_code, body=_response_json)

# This file was auto-generated by Fern from our API Definition.

import datetime as dt
import typing

import pydantic.v1 as pydantic

from ..core.datetime_utils import serialize_datetime
from ..core.pydantic_utilities import deep_union_pydantic_dicts
from .citation_parameters_style import CitationParametersStyle


class CitationParameters(pydantic.BaseModel):
    """
    Style the generator should use when making citations.
    """

    style: typing.Optional[CitationParametersStyle] = pydantic.Field(default=None)
    """
    The citation style to be used in summary.
    Can be one of:
    
    - `numeric` - Citations formatted as simple numerals: \[1\], \[2\] ...
    - `none` - Citations removed from text.
    - `html` - Citation formatted as url like `<a href="url_pattern">text_pattern</a>`.
    - `markdown` - Formatted as `[text_pattern](url_pattern)`.
    """

    url_pattern: typing.Optional[str] = pydantic.Field(default=None)
    """
    The url pattern if the citation_style is set to `html` or `markdown`.
    The pattern can access metadata attributes in the document or part.
    e.g. `https://my.doc/foo/{doc.id}/{part.id}`
    
    The default `url_pattern` is an empty string.
    """

    text_pattern: typing.Optional[str] = pydantic.Field(default=None)
    """
    The text pattern if the citation_style is set to `html` or `markdown`.
    This pattern sets the href for html or the text within `[]` in markdown,
    and defaults to N being the index of result if it is not set.
    
    The default citation style looks like `[N](<url_pattern>)` for markdown.
    
    You can use metadata attributes in the `text_pattern`. For example,
    the pattern `{doc.title}` with citation style `markdown` would result
    in final citation output like `[Title](<url_pattern>)` when
    the document's metadata includes `{"title":"Title"}`.
    """

    def json(self, **kwargs: typing.Any) -> str:
        kwargs_with_defaults: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        return super().json(**kwargs_with_defaults)

    def dict(self, **kwargs: typing.Any) -> typing.Dict[str, typing.Any]:
        kwargs_with_defaults_exclude_unset: typing.Any = {"by_alias": True, "exclude_unset": True, **kwargs}
        kwargs_with_defaults_exclude_none: typing.Any = {"by_alias": True, "exclude_none": True, **kwargs}

        return deep_union_pydantic_dicts(
            super().dict(**kwargs_with_defaults_exclude_unset), super().dict(**kwargs_with_defaults_exclude_none)
        )

    class Config:
        frozen = True
        smart_union = True
        extra = pydantic.Extra.allow
        json_encoders = {dt.datetime: serialize_datetime}
